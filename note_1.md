# 第一部分：作用域和闭包

# 1. 作用域原理

几乎所有编程语言最基本的功能之一就是能够储存变量中的值, 并在之后对其进行访问或修改. 这种能力使得程序有了状态.

那么变量中的值放在哪里? (或者说储存在哪里?)

更重要的是程序如何找到它们? 这需要设计一套良好的规则来储存变量, 并在之后方便的找到它们, 这套规则称为作用域.

## 1.1 编译原理

通常称 Javascript 为 "解释执行" 或 "动态" 语言, 但事实上它是一门编译语言. 只不过它不是提前编译的, 编译结果也不能在分布式系统上进行移植.

传统编译语言, 一段源代码在执行之前的三个步骤: (统称为编译)

1. 分词 / 词法分析 (Tokenizing / Lexing)

   将字符串分解成有意义的代码块, 这些代码块被称为词法单元 (token)

   ```
   如: var a = 2;
   会被分析为: var、a、=、2、;
   空格取决于在这门语言中是否有意义 (如 python 之类用空格缩近作为语句层级的语言)
   ```

2. 解析 / 语法分析 (Parsing)

   这个过程会将词法单元流 (往往是一个数组), 转换成 "抽象语法树" (AST: Abstract Syntax Tree)

   ```
   如: var a = 2; 通过步骤1的词法分析转换成了类似这样一个数组 ['var','a','=','2',';']
   那么转换成 AST 可能会有一个 VariableDeclaration 的顶级节点
   接下来会有一个 Identifier (它的值为a) 的子节点
   以及一个 AssignmentExpression 的子节点
   这个子节点还会有一个 Numericliteral (它的值为2) 的子节点
   ```

   可能的 AST 长这样:
   ![1-1-1.1-parsing](assets/1-1-1.1-parsing.png)

   或者可以通过更官方的工具查看:

   [在线 AST 查看](https://astexplorer.net/)

3. 代码生成

   将 AST 转换为可执行代码的过程被称为代码生成, 这个过程与编程语言, 目标平台等息息相关.

   抛开细节, 它就是这种可以将 `var a = 2;` 的 AST 转化为一组机器指令的方法.

   ```
   创建一个叫作 a 的变量 (包含内存分配等操作), 并将一个值 (数字: 2) 存到 a 中.
   ```

比起上述的三个步骤, Javascript 引擎编译要复杂的多. 比如在语法分析和代码生成阶段会有特定步骤对运行性能进行优化, 对冗余元素进行优化等.

Javascript 引擎不会有大量时间进行优化, 因为 Javascript 代码片断往往只在被执行前的几微秒 (甚至更短) 的时间内编译, Javascript 引擎会用尽各种办法 (如: JIT 或 延迟编译, 甚至实施重编译) 来保证性能最佳.

```
更多资料可以查找 V8 TurboFan 相关内容
延迟编译: Javascript 首次编译时, 部分函数仅会标记但不编译. 只有在真的执行到时, 才会编译并执行. 最常见的例子, 鼠标点击事件函数往往仅在用户第一次点击触发事件时, 这个函数才开始编译.
```

[代码](1.html)

```
会发现在 Chrome 浏览器下 (IE 下无效果, 且很慢), 后几次点击后执行 fn 的时间会明显比前二次快.
```

代码一旦编译完成, 作好执行前的准备后, 通常就会马上执行它们了.

## 1.2 理解作用域

`var a = 2`这段代码在进行处理的过程中, 有三个部分参与:

- 引擎: 从头到尾负责整个 JavaScript 程序的编译及执行过程.
- 编译器: 负责语法分析及代码生成等脏活累活.
- 作用域: 负责收集及维护所有声明的标识符(变量)组成的一系列查询. 并实施一套非常严格的规则, 确定当前执行的代码对这些标识符的访问权限.

引擎对 `var a = 2`进行分解的步骤:

1. 遇到 `var a`编译器会询问作用域是否已经有一个该名称的变量存在于当前作用域的集合中. 如果是, 编译器会忽略该声明, 继续进行编译; 否则, 它会要求作用域在当前作用域的集合中声明一个新变量, 并命名为 a.
2. 接下来, 编译器会为引擎生成运行时所需的代码, 这些代码被用来处理 `a = 2`这个赋值操作. 引擎运行时会首先询问作用域, 在当前作用域集合中是否存在一个叫作 a 的变量. 如果是, 引擎会使用这个变量. 如果否, 引擎会继续查询 (参考 1.3).
3. 如果引擎最终找到了 a 变量, 就会将 2 赋值给它. 否则, 引擎就会抛出一个异常.

编译器术语:

"LHS查询" 和 "RHS查询".

"L" 和 "R" 表示的是一个赋值操作的左侧(L)和右侧(R).

RHS 可以简单的理解为是查找某个变量中的值. 而 LHS 则试图找到变量的容器本身.

从这个角度来讲, RHS 并不是真正意义上的 "赋值操作的右侧", 更准确的说法应该是 "非左侧".

可以将 RHS 理解为 retrieve his source value (取到它的源值), 这意味着 "得到某某的值".

举个例子:

```js
console.log(a);
```

对 a 是 RHS查询, 这里只需要查找并取得 a 的值, 并将值传给 `console.log`.

另一个例子:

```js
a = 2;
```

这里对 a 则是 LHS查询, 是为了 `= 2`这个赋值操作找到一个目标.

再一个例子:

```js
function foo(a) { // 2.
    console.log(a); // 3.
}
foo(2); // 1.
```

1. 对 foo 进行 RHS查询, 因为之后要执行, 所以最好找到的 foo 能是函数类型.
2. 这里隐藏了一个 `a = 2`的操作, 为了将 2 赋值给 a, 要对 a 进行一次 LHS查询.
3. 对 a, console 各有一次 RHS 查询, 并且还要检查 console 中是否存在 log 方法.

小测试:

```js
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo(2);
```

共执行了 3 处 LHS 查询和 4 处 RHS查询

## 1.3 作用域嵌套

当一个块或函数在哪一个块或函数中时, 就发生了作用域嵌套. 因此, 在当前作用域无法找到某个变量时, 引擎会在外层嵌套的作用域中继续查找, 直到找到该变量或抵达最外层作用域 (也就是全局作用域) 为止.

```js
function foo(a) {
    console.log(a + b);
}
var b = 2;
foo(2); // 4
```

对 b 进行 RHS查询是无法在函数 foo 中完成的, 但可以在上一级作用域中完成.

## 1.4 异常

为什么区分 LHS 查询和 RHS 查询是一件非常重要的事情?

```js
function foo(a) {
    console.log(a + b);
    b = a;
}
foo(2);
```

对 b 进行的第一次 RHS查询是无法找到该变量的. 这是一个未声明的变量. RHS查询不到变量, 引擎就会抛出一个 ReferenceError 异常.

相较之下, LHS查询如果未找到变量, 在全局作用域中就会创建一个具有该名称的变量, 并将其返回给引擎. 前提是引擎在非**"严格模式"**下.

在 ES5 的严格模式下, LHS查询失败并不会创建一个全局变量, 引擎会抛出与 RHS查询失败类似的 ReferenceError 异常.

接下来, 如果 RHS查询到了一个变量, 但尝试对这个变量的值进行不合理的操作时, 引擎就会抛出另一个异常: TypeError.

- ReferenceError: 同作用域判断失败有关.
- TypeError: 代表作用域判断成功了, 但是对结果的操作是非法或不合理的.

# 总结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量赋值，则会进行LHS查询。如果目的是为了获取变量的值，则使用RHS查询。
一般情况下，赋值操作符会导致LHS查询。`=`或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

LHS和RHS查询都会在当前执行的作用域中开始，如果有需要（在当前作用域没有找到需要的标识符），就会向上一级作用域继续查找，直到最后抵达全局作用域（顶层），无论是否找到都将停止。

不成功的RHS会导致抛出 ReferenceError 异常。不成功的LHS在非严格模式下会自动隐式地创建一个全局变量。在严格模式下则会抛出 ReferenceError 异常。

# 2. 词法作用域

## 2.1 词法阶段

## 2.2 欺骗词法

- `eval`
    在严格模式下 `eval` 会运行在自己的词法作用域内，无法达到欺骗的目的
- `with`
    在非严格模式下，如果执行 `with(obj) { a = 1 }` 时，无法在 obj 上 LHS 查找到 a，则会在全局创建变量 a

# 总结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。在编译阶段的词法分析阶段基本就能够知道全部标识符在哪里以及是如何声明的，从而预测执行过程中如何对它们进行查找。

有一些欺骗手段可以达到在运行时修改词法作用域的目的。但是它们的副作用是引擎无法在编译时对作用域查找进行优化，将会导致代码运行变慢。

# 3. 函数作用域和块作用域

## 3.1 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也可以使用）

## 3.2 隐藏内部实现

隐藏函数和变量可以用来规避冲突：
- 全局命名空间
    如果加载了多个第三方库，如果它们没有妥善地将内部的变量与函数隐藏起来，就很空间引发冲突。所以这些库通常会在全局作用域中命名一个足够独特的变量，通常是对象。将这个对象作为库的命名空间，所有需要暴露给外部的功能都是这个对象的属性。
- 模块管理
    另一种方式是选用一种模块管理器，此时任何第三方库并不需要将标识符加入到全局作用域中，而是由模块管理器显式地将库的标识符导入到一个特定的作用域中。

# 3.3 函数作用域

- 匿名和具名
    虽然匿名函数表达式书写起来更快捷，许多库和工具也倾向于鼓励使用这种风格的代码，但是它仍然会有一些缺点需要考虑：
        1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
        2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 `arguments.callee`。
        3. 一个描述性的名称可以让代码更具可读性和可理解性。
- 立即执行函数表达式
    IIFE（Immediately Invoked Function Expression）

# 3.4 块作用域

- `with`
- `try/catch`
    在 ES3 规范中规定 `try/catch` 的 `catch` 分句会创建一个块作用域。
    ```js
    try {
        throw 'a'
    } catch (err) {
        console.log(err) // 'a'
    }
    console.log(err) // err 是块作用域中的变量
    ```
- `let`
    1. 垃圾收集
    2. let 循环
- `const`

# 总结

函数内部的变量或函数会在所处的作用域中隐藏起来，这是有意为之的良好的软件设计原则。

但函数并不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{}内部）。

# 4. 提升

## 4.1 先有鸡还是先有蛋

## 4.2 编译器再度来袭

## 4.3 函数优先

```js
foo() // 1
var foo
function foo() {
    console.log(1)
}
foo = function() { console.log(2) }
```

以上代码片断会被引擎理解为：

```js
function foo() {
    console.log(1)
}
foo()
foo = function() { console.log(2) }
```

# 总结

Javascript 引擎，会将代码分成二个阶段。`var` 以及 `function` 会先作为编译阶段的任务优先执行。其他的操作则会放到第二阶段的执行阶段去执行。这个过程被称为“提升”

# 5. 作用域闭包

## 5.1 启示

## 5.2 实质问题

## 5.3

## 5.4 循环与闭包

## 5.5 模块

- 现代的模块机制
- 未来的模块机制
    ES6 中为模块增加了一级语法支持，ES6 会将文件当作独立的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。

# 总结

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。